/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type MaskingFormatsFormatEntriesInitParameters struct {

	// The name of the database column. This attribute cannot be updated for an existing  masking column. Note that the same name is used for the masking column. There  is no separate displayName attribute for the masking column.
	ColumnName *string `json:"columnName,omitempty" tf:"column_name,omitempty"`

	// (Updatable) The description of the masking format.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
	EndDate *string `json:"endDate,omitempty" tf:"end_date,omitempty"`

	// (Updatable) The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
	EndLength *float64 `json:"endLength,omitempty" tf:"end_length,omitempty"`

	// (Updatable) The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
	EndValue *float64 `json:"endValue,omitempty" tf:"end_value,omitempty"`

	// (Updatable) The constant number to be used for masking.
	FixedNumber *float64 `json:"fixedNumber,omitempty" tf:"fixed_number,omitempty"`

	// (Updatable) The constant string to be used for masking.
	FixedString *string `json:"fixedString,omitempty" tf:"fixed_string,omitempty"`

	// (Applicable when type=SHUFFLE) (Updatable) One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
	GroupingColumns []*string `json:"groupingColumns,omitempty" tf:"grouping_columns,omitempty"`

	// (Updatable) The number of characters that should be there in the substring. It should be an integer and greater than zero.
	Length *float64 `json:"length,omitempty" tf:"length,omitempty"`

	// (Updatable) The OCID of the library masking format.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/datasafe/v1alpha1.LibraryMaskingFormat
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	LibraryMaskingFormatID *string `json:"libraryMaskingFormatId,omitempty" tf:"library_masking_format_id,omitempty"`

	// Reference to a LibraryMaskingFormat in datasafe to populate libraryMaskingFormatId.
	// +kubebuilder:validation:Optional
	LibraryMaskingFormatIDRef *v1.Reference `json:"libraryMaskingFormatIdRef,omitempty" tf:"-"`

	// Selector for a LibraryMaskingFormat in datasafe to populate libraryMaskingFormatId.
	// +kubebuilder:validation:Optional
	LibraryMaskingFormatIDSelector *v1.Selector `json:"libraryMaskingFormatIdSelector,omitempty" tf:"-"`

	// (Updatable) The pattern that should be used to mask data.
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`

	// (Updatable) The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
	PostProcessingFunction *string `json:"postProcessingFunction,omitempty" tf:"post_processing_function,omitempty"`

	// (Updatable) A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
	RandomList []*string `json:"randomList,omitempty" tf:"random_list,omitempty"`

	// (Updatable) The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.
	RegularExpression *string `json:"regularExpression,omitempty" tf:"regular_expression,omitempty"`

	// (Updatable) The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number or null value.
	ReplaceWith *string `json:"replaceWith,omitempty" tf:"replace_with,omitempty"`

	// (Updatable) The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
	SQLExpression *string `json:"sqlExpression,omitempty" tf:"sql_expression,omitempty"`

	// (Updatable) The name of the schema that contains the substitution column.
	SchemaName *string `json:"schemaName,omitempty" tf:"schema_name,omitempty"`

	// (Updatable) The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
	StartDate *string `json:"startDate,omitempty" tf:"start_date,omitempty"`

	// (Updatable) The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
	StartLength *float64 `json:"startLength,omitempty" tf:"start_length,omitempty"`

	// (Updatable) The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It's negative, the counting starts from the end of the string.
	StartPosition *float64 `json:"startPosition,omitempty" tf:"start_position,omitempty"`

	// (Updatable) The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
	StartValue *float64 `json:"startValue,omitempty" tf:"start_value,omitempty"`

	// (Updatable) The name of the table that contains the substitution column.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/nosql/v1alpha1.Table
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("name",false)
	TableName *string `json:"tableName,omitempty" tf:"table_name,omitempty"`

	// Reference to a Table in nosql to populate tableName.
	// +kubebuilder:validation:Optional
	TableNameRef *v1.Reference `json:"tableNameRef,omitempty" tf:"-"`

	// Selector for a Table in nosql to populate tableName.
	// +kubebuilder:validation:Optional
	TableNameSelector *v1.Selector `json:"tableNameSelector,omitempty" tf:"-"`

	// (Updatable) The type of the format entry.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (Updatable) The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
	UserDefinedFunction *string `json:"userDefinedFunction,omitempty" tf:"user_defined_function,omitempty"`
}

type MaskingFormatsFormatEntriesObservation struct {

	// The name of the database column. This attribute cannot be updated for an existing  masking column. Note that the same name is used for the masking column. There  is no separate displayName attribute for the masking column.
	ColumnName *string `json:"columnName,omitempty" tf:"column_name,omitempty"`

	// (Updatable) The description of the masking format.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
	EndDate *string `json:"endDate,omitempty" tf:"end_date,omitempty"`

	// (Updatable) The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
	EndLength *float64 `json:"endLength,omitempty" tf:"end_length,omitempty"`

	// (Updatable) The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
	EndValue *float64 `json:"endValue,omitempty" tf:"end_value,omitempty"`

	// (Updatable) The constant number to be used for masking.
	FixedNumber *float64 `json:"fixedNumber,omitempty" tf:"fixed_number,omitempty"`

	// (Updatable) The constant string to be used for masking.
	FixedString *string `json:"fixedString,omitempty" tf:"fixed_string,omitempty"`

	// (Applicable when type=SHUFFLE) (Updatable) One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
	GroupingColumns []*string `json:"groupingColumns,omitempty" tf:"grouping_columns,omitempty"`

	// (Updatable) The number of characters that should be there in the substring. It should be an integer and greater than zero.
	Length *float64 `json:"length,omitempty" tf:"length,omitempty"`

	// (Updatable) The OCID of the library masking format.
	LibraryMaskingFormatID *string `json:"libraryMaskingFormatId,omitempty" tf:"library_masking_format_id,omitempty"`

	// (Updatable) The pattern that should be used to mask data.
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`

	// (Updatable) The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
	PostProcessingFunction *string `json:"postProcessingFunction,omitempty" tf:"post_processing_function,omitempty"`

	// (Updatable) A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
	RandomList []*string `json:"randomList,omitempty" tf:"random_list,omitempty"`

	// (Updatable) The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.
	RegularExpression *string `json:"regularExpression,omitempty" tf:"regular_expression,omitempty"`

	// (Updatable) The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number or null value.
	ReplaceWith *string `json:"replaceWith,omitempty" tf:"replace_with,omitempty"`

	// (Updatable) The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
	SQLExpression *string `json:"sqlExpression,omitempty" tf:"sql_expression,omitempty"`

	// (Updatable) The name of the schema that contains the substitution column.
	SchemaName *string `json:"schemaName,omitempty" tf:"schema_name,omitempty"`

	// (Updatable) The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
	StartDate *string `json:"startDate,omitempty" tf:"start_date,omitempty"`

	// (Updatable) The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
	StartLength *float64 `json:"startLength,omitempty" tf:"start_length,omitempty"`

	// (Updatable) The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It's negative, the counting starts from the end of the string.
	StartPosition *float64 `json:"startPosition,omitempty" tf:"start_position,omitempty"`

	// (Updatable) The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
	StartValue *float64 `json:"startValue,omitempty" tf:"start_value,omitempty"`

	// (Updatable) The name of the table that contains the substitution column.
	TableName *string `json:"tableName,omitempty" tf:"table_name,omitempty"`

	// (Updatable) The type of the format entry.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (Updatable) The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
	UserDefinedFunction *string `json:"userDefinedFunction,omitempty" tf:"user_defined_function,omitempty"`
}

type MaskingFormatsFormatEntriesParameters struct {

	// The name of the database column. This attribute cannot be updated for an existing  masking column. Note that the same name is used for the masking column. There  is no separate displayName attribute for the masking column.
	// +kubebuilder:validation:Optional
	ColumnName *string `json:"columnName,omitempty" tf:"column_name,omitempty"`

	// (Updatable) The description of the masking format.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
	// +kubebuilder:validation:Optional
	EndDate *string `json:"endDate,omitempty" tf:"end_date,omitempty"`

	// (Updatable) The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
	// +kubebuilder:validation:Optional
	EndLength *float64 `json:"endLength,omitempty" tf:"end_length,omitempty"`

	// (Updatable) The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
	// +kubebuilder:validation:Optional
	EndValue *float64 `json:"endValue,omitempty" tf:"end_value,omitempty"`

	// (Updatable) The constant number to be used for masking.
	// +kubebuilder:validation:Optional
	FixedNumber *float64 `json:"fixedNumber,omitempty" tf:"fixed_number,omitempty"`

	// (Updatable) The constant string to be used for masking.
	// +kubebuilder:validation:Optional
	FixedString *string `json:"fixedString,omitempty" tf:"fixed_string,omitempty"`

	// (Applicable when type=SHUFFLE) (Updatable) One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
	// +kubebuilder:validation:Optional
	GroupingColumns []*string `json:"groupingColumns,omitempty" tf:"grouping_columns,omitempty"`

	// (Updatable) The number of characters that should be there in the substring. It should be an integer and greater than zero.
	// +kubebuilder:validation:Optional
	Length *float64 `json:"length,omitempty" tf:"length,omitempty"`

	// (Updatable) The OCID of the library masking format.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/datasafe/v1alpha1.LibraryMaskingFormat
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	LibraryMaskingFormatID *string `json:"libraryMaskingFormatId,omitempty" tf:"library_masking_format_id,omitempty"`

	// Reference to a LibraryMaskingFormat in datasafe to populate libraryMaskingFormatId.
	// +kubebuilder:validation:Optional
	LibraryMaskingFormatIDRef *v1.Reference `json:"libraryMaskingFormatIdRef,omitempty" tf:"-"`

	// Selector for a LibraryMaskingFormat in datasafe to populate libraryMaskingFormatId.
	// +kubebuilder:validation:Optional
	LibraryMaskingFormatIDSelector *v1.Selector `json:"libraryMaskingFormatIdSelector,omitempty" tf:"-"`

	// (Updatable) The pattern that should be used to mask data.
	// +kubebuilder:validation:Optional
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`

	// (Updatable) The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
	// +kubebuilder:validation:Optional
	PostProcessingFunction *string `json:"postProcessingFunction,omitempty" tf:"post_processing_function,omitempty"`

	// (Updatable) A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
	// +kubebuilder:validation:Optional
	RandomList []*string `json:"randomList,omitempty" tf:"random_list,omitempty"`

	// (Updatable) The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.
	// +kubebuilder:validation:Optional
	RegularExpression *string `json:"regularExpression,omitempty" tf:"regular_expression,omitempty"`

	// (Updatable) The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number or null value.
	// +kubebuilder:validation:Optional
	ReplaceWith *string `json:"replaceWith,omitempty" tf:"replace_with,omitempty"`

	// (Updatable) The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
	// +kubebuilder:validation:Optional
	SQLExpression *string `json:"sqlExpression,omitempty" tf:"sql_expression,omitempty"`

	// (Updatable) The name of the schema that contains the substitution column.
	// +kubebuilder:validation:Optional
	SchemaName *string `json:"schemaName,omitempty" tf:"schema_name,omitempty"`

	// (Updatable) The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
	// +kubebuilder:validation:Optional
	StartDate *string `json:"startDate,omitempty" tf:"start_date,omitempty"`

	// (Updatable) The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
	// +kubebuilder:validation:Optional
	StartLength *float64 `json:"startLength,omitempty" tf:"start_length,omitempty"`

	// (Updatable) The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It's negative, the counting starts from the end of the string.
	// +kubebuilder:validation:Optional
	StartPosition *float64 `json:"startPosition,omitempty" tf:"start_position,omitempty"`

	// (Updatable) The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
	// +kubebuilder:validation:Optional
	StartValue *float64 `json:"startValue,omitempty" tf:"start_value,omitempty"`

	// (Updatable) The name of the table that contains the substitution column.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/nosql/v1alpha1.Table
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("name",false)
	// +kubebuilder:validation:Optional
	TableName *string `json:"tableName,omitempty" tf:"table_name,omitempty"`

	// Reference to a Table in nosql to populate tableName.
	// +kubebuilder:validation:Optional
	TableNameRef *v1.Reference `json:"tableNameRef,omitempty" tf:"-"`

	// Selector for a Table in nosql to populate tableName.
	// +kubebuilder:validation:Optional
	TableNameSelector *v1.Selector `json:"tableNameSelector,omitempty" tf:"-"`

	// (Updatable) The type of the format entry.
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`

	// (Updatable) The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
	// +kubebuilder:validation:Optional
	UserDefinedFunction *string `json:"userDefinedFunction,omitempty" tf:"user_defined_function,omitempty"`
}

type MaskingFormatsInitParameters struct {

	// (Updatable) A condition that must be true for applying the masking format. It can be any valid  SQL construct that can be used in a SQL predicate. It enables you to do  conditional masking  so that you can mask the column data values differently using different masking  formats and the associated conditions.
	Condition *string `json:"condition,omitempty" tf:"condition,omitempty"`

	// (Updatable) The description of the masking format.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) An array of format entries. The combined output of all the format entries is  used for masking the column data values.
	FormatEntries []MaskingFormatsFormatEntriesInitParameters `json:"formatEntries,omitempty" tf:"format_entries,omitempty"`
}

type MaskingFormatsObservation struct {

	// (Updatable) A condition that must be true for applying the masking format. It can be any valid  SQL construct that can be used in a SQL predicate. It enables you to do  conditional masking  so that you can mask the column data values differently using different masking  formats and the associated conditions.
	Condition *string `json:"condition,omitempty" tf:"condition,omitempty"`

	// (Updatable) The description of the masking format.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) An array of format entries. The combined output of all the format entries is  used for masking the column data values.
	FormatEntries []MaskingFormatsFormatEntriesObservation `json:"formatEntries,omitempty" tf:"format_entries,omitempty"`
}

type MaskingFormatsParameters struct {

	// (Updatable) A condition that must be true for applying the masking format. It can be any valid  SQL construct that can be used in a SQL predicate. It enables you to do  conditional masking  so that you can mask the column data values differently using different masking  formats and the associated conditions.
	// +kubebuilder:validation:Optional
	Condition *string `json:"condition,omitempty" tf:"condition,omitempty"`

	// (Updatable) The description of the masking format.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) An array of format entries. The combined output of all the format entries is  used for masking the column data values.
	// +kubebuilder:validation:Optional
	FormatEntries []MaskingFormatsFormatEntriesParameters `json:"formatEntries" tf:"format_entries,omitempty"`
}

type MaskingPoliciesMaskingColumnInitParameters struct {

	// The name of the database column. This attribute cannot be updated for an existing  masking column. Note that the same name is used for the masking column. There  is no separate displayName attribute for the masking column.
	ColumnName *string `json:"columnName,omitempty" tf:"column_name,omitempty"`

	// (Updatable) Indicates whether data masking is enabled for the masking column. Set it to false if  you don't want to mask the column.
	IsMaskingEnabled *bool `json:"isMaskingEnabled,omitempty" tf:"is_masking_enabled,omitempty"`

	// (Updatable) The group of the masking column. It's a masking group identifier and can be any string  of acceptable length. All the columns in a group are masked together to ensure that  the masked data across these columns continue to retain the same logical relationship.  For more details, check  Group Masking in the Data Safe documentation.
	MaskingColumnGroup *string `json:"maskingColumnGroup,omitempty" tf:"masking_column_group,omitempty"`

	// (Updatable) The masking formats to be assigned to the masking column. You can specify a condition  as part of each masking format. It enables you to do  conditional masking  so that you can mask the column data values differently using different masking  formats and the associated conditions. A masking format can have one or more format  entries. The combined output of all the format entries is used for masking. It  provides the flexibility to define a masking format that can generate different parts  of a data value separately and then combine them to get the final data value for masking.
	MaskingFormats []MaskingFormatsInitParameters `json:"maskingFormats,omitempty" tf:"masking_formats,omitempty"`

	// The OCID of the masking policy.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/datasafe/v1alpha1.MaskingPolicy
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	MaskingPolicyID *string `json:"maskingPolicyId,omitempty" tf:"masking_policy_id,omitempty"`

	// Reference to a MaskingPolicy in datasafe to populate maskingPolicyId.
	// +kubebuilder:validation:Optional
	MaskingPolicyIDRef *v1.Reference `json:"maskingPolicyIdRef,omitempty" tf:"-"`

	// Selector for a MaskingPolicy in datasafe to populate maskingPolicyId.
	// +kubebuilder:validation:Optional
	MaskingPolicyIDSelector *v1.Selector `json:"maskingPolicyIdSelector,omitempty" tf:"-"`

	// The name of the object (table or editioning view) that contains the database column. This attribute cannot be updated for an existing masking column.
	Object *string `json:"object,omitempty" tf:"object,omitempty"`

	// (Updatable) The type of the object that contains the database column.
	ObjectType *string `json:"objectType,omitempty" tf:"object_type,omitempty"`

	// (Updatable) The name of the schema that contains the substitution column.
	SchemaName *string `json:"schemaName,omitempty" tf:"schema_name,omitempty"`

	// (Updatable) The OCID of the sensitive type to be associated with the masking column. Note that  if the maskingFormats attribute isn't provided while creating a masking column,   the default masking format associated with the specified sensitive type is assigned  to the masking column.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/datasafe/v1alpha1.SensitiveType
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	SensitiveTypeID *string `json:"sensitiveTypeId,omitempty" tf:"sensitive_type_id,omitempty"`

	// Reference to a SensitiveType in datasafe to populate sensitiveTypeId.
	// +kubebuilder:validation:Optional
	SensitiveTypeIDRef *v1.Reference `json:"sensitiveTypeIdRef,omitempty" tf:"-"`

	// Selector for a SensitiveType in datasafe to populate sensitiveTypeId.
	// +kubebuilder:validation:Optional
	SensitiveTypeIDSelector *v1.Selector `json:"sensitiveTypeIdSelector,omitempty" tf:"-"`
}

type MaskingPoliciesMaskingColumnObservation struct {

	// An array of child columns that are in referential relationship with the masking column.
	ChildColumns []*string `json:"childColumns,omitempty" tf:"child_columns,omitempty"`

	// The name of the database column. This attribute cannot be updated for an existing  masking column. Note that the same name is used for the masking column. There  is no separate displayName attribute for the masking column.
	ColumnName *string `json:"columnName,omitempty" tf:"column_name,omitempty"`

	// The data type of the masking column.
	DataType *string `json:"dataType,omitempty" tf:"data_type,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Updatable) Indicates whether data masking is enabled for the masking column. Set it to false if  you don't want to mask the column.
	IsMaskingEnabled *bool `json:"isMaskingEnabled,omitempty" tf:"is_masking_enabled,omitempty"`

	// The unique key that identifies the masking column. It's numeric and unique within a masking policy.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// Details about the current state of the masking column.
	LifecycleDetails *string `json:"lifecycleDetails,omitempty" tf:"lifecycle_details,omitempty"`

	// (Updatable) The group of the masking column. It's a masking group identifier and can be any string  of acceptable length. All the columns in a group are masked together to ensure that  the masked data across these columns continue to retain the same logical relationship.  For more details, check  Group Masking in the Data Safe documentation.
	MaskingColumnGroup *string `json:"maskingColumnGroup,omitempty" tf:"masking_column_group,omitempty"`

	// (Updatable) The masking formats to be assigned to the masking column. You can specify a condition  as part of each masking format. It enables you to do  conditional masking  so that you can mask the column data values differently using different masking  formats and the associated conditions. A masking format can have one or more format  entries. The combined output of all the format entries is used for masking. It  provides the flexibility to define a masking format that can generate different parts  of a data value separately and then combine them to get the final data value for masking.
	MaskingFormats []MaskingFormatsObservation `json:"maskingFormats,omitempty" tf:"masking_formats,omitempty"`

	// The OCID of the masking policy.
	MaskingPolicyID *string `json:"maskingPolicyId,omitempty" tf:"masking_policy_id,omitempty"`

	// The name of the object (table or editioning view) that contains the database column. This attribute cannot be updated for an existing masking column.
	Object *string `json:"object,omitempty" tf:"object,omitempty"`

	// (Updatable) The type of the object that contains the database column.
	ObjectType *string `json:"objectType,omitempty" tf:"object_type,omitempty"`

	// (Updatable) The name of the schema that contains the substitution column.
	SchemaName *string `json:"schemaName,omitempty" tf:"schema_name,omitempty"`

	// (Updatable) The OCID of the sensitive type to be associated with the masking column. Note that  if the maskingFormats attribute isn't provided while creating a masking column,   the default masking format associated with the specified sensitive type is assigned  to the masking column.
	SensitiveTypeID *string `json:"sensitiveTypeId,omitempty" tf:"sensitive_type_id,omitempty"`

	// The current state of the masking column.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// The date and time the masking column was created, in the format defined by RFC3339.
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	// The date and time the masking column was last updated, in the format defined by RFC3339.
	TimeUpdated *string `json:"timeUpdated,omitempty" tf:"time_updated,omitempty"`
}

type MaskingPoliciesMaskingColumnParameters struct {

	// The name of the database column. This attribute cannot be updated for an existing  masking column. Note that the same name is used for the masking column. There  is no separate displayName attribute for the masking column.
	// +kubebuilder:validation:Optional
	ColumnName *string `json:"columnName,omitempty" tf:"column_name,omitempty"`

	// (Updatable) Indicates whether data masking is enabled for the masking column. Set it to false if  you don't want to mask the column.
	// +kubebuilder:validation:Optional
	IsMaskingEnabled *bool `json:"isMaskingEnabled,omitempty" tf:"is_masking_enabled,omitempty"`

	// (Updatable) The group of the masking column. It's a masking group identifier and can be any string  of acceptable length. All the columns in a group are masked together to ensure that  the masked data across these columns continue to retain the same logical relationship.  For more details, check  Group Masking in the Data Safe documentation.
	// +kubebuilder:validation:Optional
	MaskingColumnGroup *string `json:"maskingColumnGroup,omitempty" tf:"masking_column_group,omitempty"`

	// (Updatable) The masking formats to be assigned to the masking column. You can specify a condition  as part of each masking format. It enables you to do  conditional masking  so that you can mask the column data values differently using different masking  formats and the associated conditions. A masking format can have one or more format  entries. The combined output of all the format entries is used for masking. It  provides the flexibility to define a masking format that can generate different parts  of a data value separately and then combine them to get the final data value for masking.
	// +kubebuilder:validation:Optional
	MaskingFormats []MaskingFormatsParameters `json:"maskingFormats,omitempty" tf:"masking_formats,omitempty"`

	// The OCID of the masking policy.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/datasafe/v1alpha1.MaskingPolicy
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	MaskingPolicyID *string `json:"maskingPolicyId,omitempty" tf:"masking_policy_id,omitempty"`

	// Reference to a MaskingPolicy in datasafe to populate maskingPolicyId.
	// +kubebuilder:validation:Optional
	MaskingPolicyIDRef *v1.Reference `json:"maskingPolicyIdRef,omitempty" tf:"-"`

	// Selector for a MaskingPolicy in datasafe to populate maskingPolicyId.
	// +kubebuilder:validation:Optional
	MaskingPolicyIDSelector *v1.Selector `json:"maskingPolicyIdSelector,omitempty" tf:"-"`

	// The name of the object (table or editioning view) that contains the database column. This attribute cannot be updated for an existing masking column.
	// +kubebuilder:validation:Optional
	Object *string `json:"object,omitempty" tf:"object,omitempty"`

	// (Updatable) The type of the object that contains the database column.
	// +kubebuilder:validation:Optional
	ObjectType *string `json:"objectType,omitempty" tf:"object_type,omitempty"`

	// (Updatable) The name of the schema that contains the substitution column.
	// +kubebuilder:validation:Optional
	SchemaName *string `json:"schemaName,omitempty" tf:"schema_name,omitempty"`

	// (Updatable) The OCID of the sensitive type to be associated with the masking column. Note that  if the maskingFormats attribute isn't provided while creating a masking column,   the default masking format associated with the specified sensitive type is assigned  to the masking column.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/datasafe/v1alpha1.SensitiveType
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	SensitiveTypeID *string `json:"sensitiveTypeId,omitempty" tf:"sensitive_type_id,omitempty"`

	// Reference to a SensitiveType in datasafe to populate sensitiveTypeId.
	// +kubebuilder:validation:Optional
	SensitiveTypeIDRef *v1.Reference `json:"sensitiveTypeIdRef,omitempty" tf:"-"`

	// Selector for a SensitiveType in datasafe to populate sensitiveTypeId.
	// +kubebuilder:validation:Optional
	SensitiveTypeIDSelector *v1.Selector `json:"sensitiveTypeIdSelector,omitempty" tf:"-"`
}

// MaskingPoliciesMaskingColumnSpec defines the desired state of MaskingPoliciesMaskingColumn
type MaskingPoliciesMaskingColumnSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     MaskingPoliciesMaskingColumnParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider MaskingPoliciesMaskingColumnInitParameters `json:"initProvider,omitempty"`
}

// MaskingPoliciesMaskingColumnStatus defines the observed state of MaskingPoliciesMaskingColumn.
type MaskingPoliciesMaskingColumnStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MaskingPoliciesMaskingColumnObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// MaskingPoliciesMaskingColumn is the Schema for the MaskingPoliciesMaskingColumns API. Provides the Masking Policies Masking Column resource in Oracle Cloud Infrastructure Data Safe service
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,oci}
type MaskingPoliciesMaskingColumn struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.columnName) || (has(self.initProvider) && has(self.initProvider.columnName))",message="spec.forProvider.columnName is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.object) || (has(self.initProvider) && has(self.initProvider.object))",message="spec.forProvider.object is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.schemaName) || (has(self.initProvider) && has(self.initProvider.schemaName))",message="spec.forProvider.schemaName is a required parameter"
	Spec   MaskingPoliciesMaskingColumnSpec   `json:"spec"`
	Status MaskingPoliciesMaskingColumnStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MaskingPoliciesMaskingColumnList contains a list of MaskingPoliciesMaskingColumns
type MaskingPoliciesMaskingColumnList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []MaskingPoliciesMaskingColumn `json:"items"`
}

// Repository type metadata.
var (
	MaskingPoliciesMaskingColumn_Kind             = "MaskingPoliciesMaskingColumn"
	MaskingPoliciesMaskingColumn_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: MaskingPoliciesMaskingColumn_Kind}.String()
	MaskingPoliciesMaskingColumn_KindAPIVersion   = MaskingPoliciesMaskingColumn_Kind + "." + CRDGroupVersion.String()
	MaskingPoliciesMaskingColumn_GroupVersionKind = CRDGroupVersion.WithKind(MaskingPoliciesMaskingColumn_Kind)
)

func init() {
	SchemeBuilder.Register(&MaskingPoliciesMaskingColumn{}, &MaskingPoliciesMaskingColumnList{})
}
