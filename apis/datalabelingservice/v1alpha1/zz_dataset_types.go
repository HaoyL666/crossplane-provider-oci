/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type DatasetFormatDetailsInitParameters struct {

	// The format type. DOCUMENT format is for record contents that are PDFs or TIFFs. IMAGE format is for record contents that are JPEGs or PNGs. TEXT format is for record contents that are TXT files.
	FormatType *string `json:"formatType,omitempty" tf:"format_type,omitempty"`

	// (Applicable when format_type=TEXT) Metadata for files with text content.
	TextFileTypeMetadata []TextFileTypeMetadataInitParameters `json:"textFileTypeMetadata,omitempty" tf:"text_file_type_metadata,omitempty"`
}

type DatasetFormatDetailsObservation struct {

	// The format type. DOCUMENT format is for record contents that are PDFs or TIFFs. IMAGE format is for record contents that are JPEGs or PNGs. TEXT format is for record contents that are TXT files.
	FormatType *string `json:"formatType,omitempty" tf:"format_type,omitempty"`

	// (Applicable when format_type=TEXT) Metadata for files with text content.
	TextFileTypeMetadata []TextFileTypeMetadataObservation `json:"textFileTypeMetadata,omitempty" tf:"text_file_type_metadata,omitempty"`
}

type DatasetFormatDetailsParameters struct {

	// The format type. DOCUMENT format is for record contents that are PDFs or TIFFs. IMAGE format is for record contents that are JPEGs or PNGs. TEXT format is for record contents that are TXT files.
	// +kubebuilder:validation:Optional
	FormatType *string `json:"formatType" tf:"format_type,omitempty"`

	// (Applicable when format_type=TEXT) Metadata for files with text content.
	// +kubebuilder:validation:Optional
	TextFileTypeMetadata []TextFileTypeMetadataParameters `json:"textFileTypeMetadata,omitempty" tf:"text_file_type_metadata,omitempty"`
}

type DatasetInitParameters struct {

	// The annotation format name required for labeling records.
	AnnotationFormat *string `json:"annotationFormat,omitempty" tf:"annotation_format,omitempty"`

	// (Updatable) The OCID of the compartment of the resource.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/identity/v1alpha1.Compartment
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// Reference to a Compartment in identity to populate compartmentId.
	// +kubebuilder:validation:Optional
	CompartmentIDRef *v1.Reference `json:"compartmentIdRef,omitempty" tf:"-"`

	// Selector for a Compartment in identity to populate compartmentId.
	// +kubebuilder:validation:Optional
	CompartmentIDSelector *v1.Selector `json:"compartmentIdSelector,omitempty" tf:"-"`

	// It specifies how to process the data. Supported formats include DOCUMENT, IMAGE, and TEXT.
	DatasetFormatDetails []DatasetFormatDetailsInitParameters `json:"datasetFormatDetails,omitempty" tf:"dataset_format_details,omitempty"`

	// This allows the customer to specify the source of the dataset.
	DatasetSourceDetails []DatasetSourceDetailsInitParameters `json:"datasetSourceDetails,omitempty" tf:"dataset_source_details,omitempty"`

	// (Updatable) The defined tags for this resource. Each key is predefined and scoped to a namespace. For example: {"foo-namespace": {"bar-key": "value"}}
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) A user provided description of the dataset
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) A user-friendly display name for the resource.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (Updatable) A simple key-value pair that is applied without any predefined name, type, or scope. It exists for cross-compatibility only. For example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// Initial import dataset configuration. Allows user to create dataset from existing dataset files.
	InitialImportDatasetConfiguration []InitialImportDatasetConfigurationInitParameters `json:"initialImportDatasetConfiguration,omitempty" tf:"initial_import_dataset_configuration,omitempty"`

	// The initial generate records configuration. It generates records from the dataset's source.
	InitialRecordGenerationConfiguration []InitialRecordGenerationConfigurationInitParameters `json:"initialRecordGenerationConfiguration,omitempty" tf:"initial_record_generation_configuration,omitempty"`

	// An ordered collection of labels that are unique by name.
	LabelSet []LabelSetInitParameters `json:"labelSet,omitempty" tf:"label_set,omitempty"`

	// (Updatable) The labeling instructions for human labelers in rich text format
	LabelingInstructions *string `json:"labelingInstructions,omitempty" tf:"labeling_instructions,omitempty"`
}

type DatasetObservation struct {

	// A simple key-value pair that is applied without any predefined name, type, or scope. It exists for cross-compatibility only. For example: {"bar-key": "value"}
	// +mapType=granular
	AdditionalProperties map[string]*string `json:"additionalProperties,omitempty" tf:"additional_properties,omitempty"`

	// The annotation format name required for labeling records.
	AnnotationFormat *string `json:"annotationFormat,omitempty" tf:"annotation_format,omitempty"`

	// (Updatable) The OCID of the compartment of the resource.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// It specifies how to process the data. Supported formats include DOCUMENT, IMAGE, and TEXT.
	DatasetFormatDetails []DatasetFormatDetailsObservation `json:"datasetFormatDetails,omitempty" tf:"dataset_format_details,omitempty"`

	// This allows the customer to specify the source of the dataset.
	DatasetSourceDetails []DatasetSourceDetailsObservation `json:"datasetSourceDetails,omitempty" tf:"dataset_source_details,omitempty"`

	// (Updatable) The defined tags for this resource. Each key is predefined and scoped to a namespace. For example: {"foo-namespace": {"bar-key": "value"}}
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) A user provided description of the dataset
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) A user-friendly display name for the resource.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (Updatable) A simple key-value pair that is applied without any predefined name, type, or scope. It exists for cross-compatibility only. For example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// The OCID of the Dataset.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Initial import dataset configuration. Allows user to create dataset from existing dataset files.
	InitialImportDatasetConfiguration []InitialImportDatasetConfigurationObservation `json:"initialImportDatasetConfiguration,omitempty" tf:"initial_import_dataset_configuration,omitempty"`

	// The initial generate records configuration. It generates records from the dataset's source.
	InitialRecordGenerationConfiguration []InitialRecordGenerationConfigurationParameters `json:"initialRecordGenerationConfiguration,omitempty" tf:"initial_record_generation_configuration,omitempty"`

	// An ordered collection of labels that are unique by name.
	LabelSet []LabelSetObservation `json:"labelSet,omitempty" tf:"label_set,omitempty"`

	// (Updatable) The labeling instructions for human labelers in rich text format
	LabelingInstructions *string `json:"labelingInstructions,omitempty" tf:"labeling_instructions,omitempty"`

	// A message describing the current state in more detail. For example, it can be used to provide actionable information for a resource in FAILED or NEEDS_ATTENTION state.
	LifecycleDetails *string `json:"lifecycleDetails,omitempty" tf:"lifecycle_details,omitempty"`

	// The sub-state of the dataset. IMPORT_DATASET - The dataset is being imported.
	LifecycleSubstate *string `json:"lifecycleSubstate,omitempty" tf:"lifecycle_substate,omitempty"`

	// The state of a dataset. CREATING - The dataset is being created.  It will transition to ACTIVE when it is ready for labeling. ACTIVE   - The dataset is ready for labeling. UPDATING - The dataset is being updated.  It and its related resources may be unavailable for other updates until it returns to ACTIVE. NEEDS_ATTENTION - A dataset updation operation has failed due to validation or other errors and needs attention. DELETING - The dataset and its related resources are being deleted. DELETED  - The dataset has been deleted and is no longer available. FAILED   - The dataset has failed due to validation or other errors.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// The date and time the resource was created, in the timestamp format defined by RFC3339.
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	// The date and time the resource was last updated, in the timestamp format defined by RFC3339.
	TimeUpdated *string `json:"timeUpdated,omitempty" tf:"time_updated,omitempty"`
}

type DatasetParameters struct {

	// The annotation format name required for labeling records.
	// +kubebuilder:validation:Optional
	AnnotationFormat *string `json:"annotationFormat,omitempty" tf:"annotation_format,omitempty"`

	// (Updatable) The OCID of the compartment of the resource.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/identity/v1alpha1.Compartment
	// +kubebuilder:validation:Optional
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// Reference to a Compartment in identity to populate compartmentId.
	// +kubebuilder:validation:Optional
	CompartmentIDRef *v1.Reference `json:"compartmentIdRef,omitempty" tf:"-"`

	// Selector for a Compartment in identity to populate compartmentId.
	// +kubebuilder:validation:Optional
	CompartmentIDSelector *v1.Selector `json:"compartmentIdSelector,omitempty" tf:"-"`

	// It specifies how to process the data. Supported formats include DOCUMENT, IMAGE, and TEXT.
	// +kubebuilder:validation:Optional
	DatasetFormatDetails []DatasetFormatDetailsParameters `json:"datasetFormatDetails,omitempty" tf:"dataset_format_details,omitempty"`

	// This allows the customer to specify the source of the dataset.
	// +kubebuilder:validation:Optional
	DatasetSourceDetails []DatasetSourceDetailsParameters `json:"datasetSourceDetails,omitempty" tf:"dataset_source_details,omitempty"`

	// (Updatable) The defined tags for this resource. Each key is predefined and scoped to a namespace. For example: {"foo-namespace": {"bar-key": "value"}}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) A user provided description of the dataset
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) A user-friendly display name for the resource.
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (Updatable) A simple key-value pair that is applied without any predefined name, type, or scope. It exists for cross-compatibility only. For example: {"bar-key": "value"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// Initial import dataset configuration. Allows user to create dataset from existing dataset files.
	// +kubebuilder:validation:Optional
	InitialImportDatasetConfiguration []InitialImportDatasetConfigurationParameters `json:"initialImportDatasetConfiguration,omitempty" tf:"initial_import_dataset_configuration,omitempty"`

	// The initial generate records configuration. It generates records from the dataset's source.
	// +kubebuilder:validation:Optional
	InitialRecordGenerationConfiguration []InitialRecordGenerationConfigurationParameters `json:"initialRecordGenerationConfiguration,omitempty" tf:"initial_record_generation_configuration,omitempty"`

	// An ordered collection of labels that are unique by name.
	// +kubebuilder:validation:Optional
	LabelSet []LabelSetParameters `json:"labelSet,omitempty" tf:"label_set,omitempty"`

	// (Updatable) The labeling instructions for human labelers in rich text format
	// +kubebuilder:validation:Optional
	LabelingInstructions *string `json:"labelingInstructions,omitempty" tf:"labeling_instructions,omitempty"`
}

type DatasetSourceDetailsInitParameters struct {

	// The object storage bucket that contains the dataset data source.
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// The namespace of the bucket that contains the dataset data source.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// A common path prefix shared by the objects that make up the dataset. Except for the CSV file type, records are not generated for the objects whose names exactly match with the prefix.
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// The source type. OBJECT_STORAGE allows the user to describe where in object storage the dataset is.
	SourceType *string `json:"sourceType,omitempty" tf:"source_type,omitempty"`
}

type DatasetSourceDetailsObservation struct {

	// The object storage bucket that contains the dataset data source.
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// The namespace of the bucket that contains the dataset data source.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// A common path prefix shared by the objects that make up the dataset. Except for the CSV file type, records are not generated for the objects whose names exactly match with the prefix.
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// The source type. OBJECT_STORAGE allows the user to describe where in object storage the dataset is.
	SourceType *string `json:"sourceType,omitempty" tf:"source_type,omitempty"`
}

type DatasetSourceDetailsParameters struct {

	// The object storage bucket that contains the dataset data source.
	// +kubebuilder:validation:Optional
	Bucket *string `json:"bucket" tf:"bucket,omitempty"`

	// The namespace of the bucket that contains the dataset data source.
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace" tf:"namespace,omitempty"`

	// A common path prefix shared by the objects that make up the dataset. Except for the CSV file type, records are not generated for the objects whose names exactly match with the prefix.
	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// The source type. OBJECT_STORAGE allows the user to describe where in object storage the dataset is.
	// +kubebuilder:validation:Optional
	SourceType *string `json:"sourceType" tf:"source_type,omitempty"`
}

type ImportFormatInitParameters struct {

	// Name of import format
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Version of import format
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type ImportFormatObservation struct {

	// Name of import format
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Version of import format
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type ImportFormatParameters struct {

	// Name of import format
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// Version of import format
	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type ImportMetadataPathInitParameters struct {

	// The object storage bucket that contains the dataset data source.
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// The namespace of the bucket that contains the dataset data source.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Path for the metadata file.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// The source type. OBJECT_STORAGE allows the user to describe where in object storage the dataset is.
	SourceType *string `json:"sourceType,omitempty" tf:"source_type,omitempty"`
}

type ImportMetadataPathObservation struct {

	// The object storage bucket that contains the dataset data source.
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// The namespace of the bucket that contains the dataset data source.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Path for the metadata file.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// The source type. OBJECT_STORAGE allows the user to describe where in object storage the dataset is.
	SourceType *string `json:"sourceType,omitempty" tf:"source_type,omitempty"`
}

type ImportMetadataPathParameters struct {

	// The object storage bucket that contains the dataset data source.
	// +kubebuilder:validation:Optional
	Bucket *string `json:"bucket" tf:"bucket,omitempty"`

	// The namespace of the bucket that contains the dataset data source.
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace" tf:"namespace,omitempty"`

	// Path for the metadata file.
	// +kubebuilder:validation:Optional
	Path *string `json:"path" tf:"path,omitempty"`

	// The source type. OBJECT_STORAGE allows the user to describe where in object storage the dataset is.
	// +kubebuilder:validation:Optional
	SourceType *string `json:"sourceType" tf:"source_type,omitempty"`
}

type InitialImportDatasetConfigurationInitParameters struct {

	// File format details used for importing dataset
	ImportFormat []ImportFormatInitParameters `json:"importFormat,omitempty" tf:"import_format,omitempty"`

	// Object storage path for the metadata file
	ImportMetadataPath []ImportMetadataPathInitParameters `json:"importMetadataPath,omitempty" tf:"import_metadata_path,omitempty"`
}

type InitialImportDatasetConfigurationObservation struct {

	// File format details used for importing dataset
	ImportFormat []ImportFormatObservation `json:"importFormat,omitempty" tf:"import_format,omitempty"`

	// Object storage path for the metadata file
	ImportMetadataPath []ImportMetadataPathObservation `json:"importMetadataPath,omitempty" tf:"import_metadata_path,omitempty"`
}

type InitialImportDatasetConfigurationParameters struct {

	// File format details used for importing dataset
	// +kubebuilder:validation:Optional
	ImportFormat []ImportFormatParameters `json:"importFormat" tf:"import_format,omitempty"`

	// Object storage path for the metadata file
	// +kubebuilder:validation:Optional
	ImportMetadataPath []ImportMetadataPathParameters `json:"importMetadataPath" tf:"import_metadata_path,omitempty"`
}

type InitialRecordGenerationConfigurationInitParameters struct {
}

type InitialRecordGenerationConfigurationObservation struct {
}

type InitialRecordGenerationConfigurationParameters struct {
}

type ItemsInitParameters struct {

	// Name of import format
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type ItemsObservation struct {

	// Name of import format
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type ItemsParameters struct {

	// Name of import format
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`
}

type LabelSetInitParameters struct {

	// An ordered collection of labels that are unique by name.
	Items []ItemsInitParameters `json:"items,omitempty" tf:"items,omitempty"`
}

type LabelSetObservation struct {

	// An ordered collection of labels that are unique by name.
	Items []ItemsObservation `json:"items,omitempty" tf:"items,omitempty"`
}

type LabelSetParameters struct {

	// An ordered collection of labels that are unique by name.
	// +kubebuilder:validation:Optional
	Items []ItemsParameters `json:"items" tf:"items,omitempty"`
}

type TextFileTypeMetadataInitParameters struct {

	// A column delimiter
	ColumnDelimiter *string `json:"columnDelimiter,omitempty" tf:"column_delimiter,omitempty"`

	// The index of a selected column. This is a zero-based index.
	ColumnIndex *float64 `json:"columnIndex,omitempty" tf:"column_index,omitempty"`

	// The name of a selected column.
	ColumnName *string `json:"columnName,omitempty" tf:"column_name,omitempty"`

	// An escape character.
	EscapeCharacter *string `json:"escapeCharacter,omitempty" tf:"escape_character,omitempty"`

	// The format type. DOCUMENT format is for record contents that are PDFs or TIFFs. IMAGE format is for record contents that are JPEGs or PNGs. TEXT format is for record contents that are TXT files.
	FormatType *string `json:"formatType,omitempty" tf:"format_type,omitempty"`

	// A line delimiter.
	LineDelimiter *string `json:"lineDelimiter,omitempty" tf:"line_delimiter,omitempty"`
}

type TextFileTypeMetadataObservation struct {

	// A column delimiter
	ColumnDelimiter *string `json:"columnDelimiter,omitempty" tf:"column_delimiter,omitempty"`

	// The index of a selected column. This is a zero-based index.
	ColumnIndex *float64 `json:"columnIndex,omitempty" tf:"column_index,omitempty"`

	// The name of a selected column.
	ColumnName *string `json:"columnName,omitempty" tf:"column_name,omitempty"`

	// An escape character.
	EscapeCharacter *string `json:"escapeCharacter,omitempty" tf:"escape_character,omitempty"`

	// The format type. DOCUMENT format is for record contents that are PDFs or TIFFs. IMAGE format is for record contents that are JPEGs or PNGs. TEXT format is for record contents that are TXT files.
	FormatType *string `json:"formatType,omitempty" tf:"format_type,omitempty"`

	// A line delimiter.
	LineDelimiter *string `json:"lineDelimiter,omitempty" tf:"line_delimiter,omitempty"`
}

type TextFileTypeMetadataParameters struct {

	// A column delimiter
	// +kubebuilder:validation:Optional
	ColumnDelimiter *string `json:"columnDelimiter,omitempty" tf:"column_delimiter,omitempty"`

	// The index of a selected column. This is a zero-based index.
	// +kubebuilder:validation:Optional
	ColumnIndex *float64 `json:"columnIndex" tf:"column_index,omitempty"`

	// The name of a selected column.
	// +kubebuilder:validation:Optional
	ColumnName *string `json:"columnName,omitempty" tf:"column_name,omitempty"`

	// An escape character.
	// +kubebuilder:validation:Optional
	EscapeCharacter *string `json:"escapeCharacter,omitempty" tf:"escape_character,omitempty"`

	// The format type. DOCUMENT format is for record contents that are PDFs or TIFFs. IMAGE format is for record contents that are JPEGs or PNGs. TEXT format is for record contents that are TXT files.
	// +kubebuilder:validation:Optional
	FormatType *string `json:"formatType" tf:"format_type,omitempty"`

	// A line delimiter.
	// +kubebuilder:validation:Optional
	LineDelimiter *string `json:"lineDelimiter,omitempty" tf:"line_delimiter,omitempty"`
}

// DatasetSpec defines the desired state of Dataset
type DatasetSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     DatasetParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider DatasetInitParameters `json:"initProvider,omitempty"`
}

// DatasetStatus defines the observed state of Dataset.
type DatasetStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        DatasetObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Dataset is the Schema for the Datasets API. Provides the Dataset resource in Oracle Cloud Infrastructure Data Labeling Service service
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,oci}
type Dataset struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.annotationFormat) || (has(self.initProvider) && has(self.initProvider.annotationFormat))",message="spec.forProvider.annotationFormat is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.datasetFormatDetails) || (has(self.initProvider) && has(self.initProvider.datasetFormatDetails))",message="spec.forProvider.datasetFormatDetails is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.datasetSourceDetails) || (has(self.initProvider) && has(self.initProvider.datasetSourceDetails))",message="spec.forProvider.datasetSourceDetails is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.labelSet) || (has(self.initProvider) && has(self.initProvider.labelSet))",message="spec.forProvider.labelSet is a required parameter"
	Spec   DatasetSpec   `json:"spec"`
	Status DatasetStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// DatasetList contains a list of Datasets
type DatasetList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Dataset `json:"items"`
}

// Repository type metadata.
var (
	Dataset_Kind             = "Dataset"
	Dataset_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Dataset_Kind}.String()
	Dataset_KindAPIVersion   = Dataset_Kind + "." + CRDGroupVersion.String()
	Dataset_GroupVersionKind = CRDGroupVersion.WithKind(Dataset_Kind)
)

func init() {
	SchemeBuilder.Register(&Dataset{}, &DatasetList{})
}
