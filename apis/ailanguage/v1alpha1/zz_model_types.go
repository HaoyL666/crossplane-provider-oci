/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ClassMetricsInitParameters struct {
}

type ClassMetricsObservation struct {

	// F1-score, is a measure of a model’s accuracy on a dataset
	F1 *float64 `json:"f1,omitempty" tf:"f1,omitempty"`

	// Text classification label
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
	Precision *float64 `json:"precision,omitempty" tf:"precision,omitempty"`

	// Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
	Recall *float64 `json:"recall,omitempty" tf:"recall,omitempty"`

	// number of samples in the test set
	Support *float64 `json:"support,omitempty" tf:"support,omitempty"`
}

type ClassMetricsParameters struct {
}

type ClassificationModeInitParameters struct {

	// (Applicable when model_type=TEXT_CLASSIFICATION) possible text classification modes
	ClassificationMode *string `json:"classificationMode,omitempty" tf:"classification_mode,omitempty"`

	// Optional if nothing specified latest base model will be used for training. Supported versions can be found at /modelTypes/{modelType}
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type ClassificationModeObservation struct {

	// (Applicable when model_type=TEXT_CLASSIFICATION) possible text classification modes
	ClassificationMode *string `json:"classificationMode,omitempty" tf:"classification_mode,omitempty"`

	// Optional if nothing specified latest base model will be used for training. Supported versions can be found at /modelTypes/{modelType}
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type ClassificationModeParameters struct {

	// (Applicable when model_type=TEXT_CLASSIFICATION) possible text classification modes
	// +kubebuilder:validation:Optional
	ClassificationMode *string `json:"classificationMode" tf:"classification_mode,omitempty"`

	// Optional if nothing specified latest base model will be used for training. Supported versions can be found at /modelTypes/{modelType}
	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type EntityMetricsInitParameters struct {
}

type EntityMetricsObservation struct {

	// F1-score, is a measure of a model’s accuracy on a dataset
	F1 *float64 `json:"f1,omitempty" tf:"f1,omitempty"`

	// Text classification label
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
	Precision *float64 `json:"precision,omitempty" tf:"precision,omitempty"`

	// Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
	Recall *float64 `json:"recall,omitempty" tf:"recall,omitempty"`
}

type EntityMetricsParameters struct {
}

type EvaluationResultsInitParameters struct {
}

type EvaluationResultsObservation struct {

	// List of text classification metrics
	ClassMetrics []ClassMetricsObservation `json:"classMetrics,omitempty" tf:"class_metrics,omitempty"`

	// class level confusion matrix
	ConfusionMatrix *string `json:"confusionMatrix,omitempty" tf:"confusion_matrix,omitempty"`

	// List of entity metrics
	EntityMetrics []EntityMetricsObservation `json:"entityMetrics,omitempty" tf:"entity_metrics,omitempty"`

	// labels
	Labels []*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Model level named entity recognition metrics
	Metrics []MetricsObservation `json:"metrics,omitempty" tf:"metrics,omitempty"`

	// Model type
	ModelType *string `json:"modelType,omitempty" tf:"model_type,omitempty"`
}

type EvaluationResultsParameters struct {
}

type LocationDetailsInitParameters struct {

	// Object storage bucket name
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// Possible object storage location types
	LocationType *string `json:"locationType,omitempty" tf:"location_type,omitempty"`

	// Object storage namespace
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Array of files which need to be processed in the bucket
	ObjectNames []*string `json:"objectNames,omitempty" tf:"object_names,omitempty"`
}

type LocationDetailsObservation struct {

	// Object storage bucket name
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// Possible object storage location types
	LocationType *string `json:"locationType,omitempty" tf:"location_type,omitempty"`

	// Object storage namespace
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Array of files which need to be processed in the bucket
	ObjectNames []*string `json:"objectNames,omitempty" tf:"object_names,omitempty"`
}

type LocationDetailsParameters struct {

	// Object storage bucket name
	// +kubebuilder:validation:Optional
	Bucket *string `json:"bucket" tf:"bucket,omitempty"`

	// Possible object storage location types
	// +kubebuilder:validation:Optional
	LocationType *string `json:"locationType" tf:"location_type,omitempty"`

	// Object storage namespace
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace" tf:"namespace,omitempty"`

	// Array of files which need to be processed in the bucket
	// +kubebuilder:validation:Optional
	ObjectNames []*string `json:"objectNames" tf:"object_names,omitempty"`
}

type MetricsInitParameters struct {
}

type MetricsObservation struct {

	// The fraction of the labels that were correctly recognised .
	Accuracy *float64 `json:"accuracy,omitempty" tf:"accuracy,omitempty"`

	// F1-score, is a measure of a model’s accuracy on a dataset
	MacroF1 *float64 `json:"macroF1,omitempty" tf:"macro_f1,omitempty"`

	// Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
	MacroPrecision *float64 `json:"macroPrecision,omitempty" tf:"macro_precision,omitempty"`

	// Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
	MacroRecall *float64 `json:"macroRecall,omitempty" tf:"macro_recall,omitempty"`

	// F1-score, is a measure of a model’s accuracy on a dataset
	MicroF1 *float64 `json:"microF1,omitempty" tf:"micro_f1,omitempty"`

	// Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
	MicroPrecision *float64 `json:"microPrecision,omitempty" tf:"micro_precision,omitempty"`

	// Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
	MicroRecall *float64 `json:"microRecall,omitempty" tf:"micro_recall,omitempty"`

	// F1-score, is a measure of a model’s accuracy on a dataset
	WeightedF1 *float64 `json:"weightedF1,omitempty" tf:"weighted_f1,omitempty"`

	// Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
	WeightedPrecision *float64 `json:"weightedPrecision,omitempty" tf:"weighted_precision,omitempty"`

	// Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
	WeightedRecall *float64 `json:"weightedRecall,omitempty" tf:"weighted_recall,omitempty"`
}

type MetricsParameters struct {
}

type ModelDetailsInitParameters struct {

	// (Applicable when model_type=TEXT_CLASSIFICATION) possible text classification modes
	ClassificationMode []ClassificationModeInitParameters `json:"classificationMode,omitempty" tf:"classification_mode,omitempty"`

	// supported language default value is en
	LanguageCode *string `json:"languageCode,omitempty" tf:"language_code,omitempty"`

	// Model type
	ModelType *string `json:"modelType,omitempty" tf:"model_type,omitempty"`

	// Optional if nothing specified latest base model will be used for training. Supported versions can be found at /modelTypes/{modelType}
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type ModelDetailsObservation struct {

	// (Applicable when model_type=TEXT_CLASSIFICATION) possible text classification modes
	ClassificationMode []ClassificationModeObservation `json:"classificationMode,omitempty" tf:"classification_mode,omitempty"`

	// supported language default value is en
	LanguageCode *string `json:"languageCode,omitempty" tf:"language_code,omitempty"`

	// Model type
	ModelType *string `json:"modelType,omitempty" tf:"model_type,omitempty"`

	// Optional if nothing specified latest base model will be used for training. Supported versions can be found at /modelTypes/{modelType}
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type ModelDetailsParameters struct {

	// (Applicable when model_type=TEXT_CLASSIFICATION) possible text classification modes
	// +kubebuilder:validation:Optional
	ClassificationMode []ClassificationModeParameters `json:"classificationMode,omitempty" tf:"classification_mode,omitempty"`

	// supported language default value is en
	// +kubebuilder:validation:Optional
	LanguageCode *string `json:"languageCode,omitempty" tf:"language_code,omitempty"`

	// Model type
	// +kubebuilder:validation:Optional
	ModelType *string `json:"modelType" tf:"model_type,omitempty"`

	// Optional if nothing specified latest base model will be used for training. Supported versions can be found at /modelTypes/{modelType}
	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type ModelInitParameters struct {

	// (Updatable) The OCID  for the models compartment.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/identity/v1alpha1.Compartment
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// Reference to a Compartment in identity to populate compartmentId.
	// +kubebuilder:validation:Optional
	CompartmentIDRef *v1.Reference `json:"compartmentIdRef,omitempty" tf:"-"`

	// Selector for a Compartment in identity to populate compartmentId.
	// +kubebuilder:validation:Optional
	CompartmentIDSelector *v1.Selector `json:"compartmentIdSelector,omitempty" tf:"-"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) A short description of the a model.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) A user-friendly display name for the resource. It does not have to be unique and can be modified. Avoid entering confidential information.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// Possible model types
	ModelDetails []ModelDetailsInitParameters `json:"modelDetails,omitempty" tf:"model_details,omitempty"`

	// The OCID of the project to associate with the model.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/ailanguage/v1alpha1.Project
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// Reference to a Project in ailanguage to populate projectId.
	// +kubebuilder:validation:Optional
	ProjectIDRef *v1.Reference `json:"projectIdRef,omitempty" tf:"-"`

	// Selector for a Project in ailanguage to populate projectId.
	// +kubebuilder:validation:Optional
	ProjectIDSelector *v1.Selector `json:"projectIdSelector,omitempty" tf:"-"`

	// Possible strategy as testing and validation dataset.
	TestStrategy []TestStrategyInitParameters `json:"testStrategy,omitempty" tf:"test_strategy,omitempty"`

	// Possible data set type
	TrainingDataset []TrainingDatasetInitParameters `json:"trainingDataset,omitempty" tf:"training_dataset,omitempty"`
}

type ModelObservation struct {

	// (Updatable) The OCID  for the models compartment.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) A short description of the a model.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) A user-friendly display name for the resource. It does not have to be unique and can be modified. Avoid entering confidential information.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// model training results of different models
	EvaluationResults []EvaluationResultsObservation `json:"evaluationResults,omitempty" tf:"evaluation_results,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// Unique identifier model OCID of a model that is immutable on creation
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in failed state.
	LifecycleDetails *string `json:"lifecycleDetails,omitempty" tf:"lifecycle_details,omitempty"`

	// Possible model types
	ModelDetails []ModelDetailsObservation `json:"modelDetails,omitempty" tf:"model_details,omitempty"`

	// The OCID of the project to associate with the model.
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// The state of the model.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// Usage of system tag keys. These predefined keys are scoped to namespaces. Example: {"orcl-cloud.free-tier-retained": "true"}
	// +mapType=granular
	SystemTags map[string]*string `json:"systemTags,omitempty" tf:"system_tags,omitempty"`

	// Possible strategy as testing and validation dataset.
	TestStrategy []TestStrategyObservation `json:"testStrategy,omitempty" tf:"test_strategy,omitempty"`

	// The time the the model was created. An RFC3339 formatted datetime string.
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	// The time the model was updated. An RFC3339 formatted datetime string.
	TimeUpdated *string `json:"timeUpdated,omitempty" tf:"time_updated,omitempty"`

	// Possible data set type
	TrainingDataset []TrainingDatasetObservation `json:"trainingDataset,omitempty" tf:"training_dataset,omitempty"`

	// Optional if nothing specified latest base model will be used for training. Supported versions can be found at /modelTypes/{modelType}
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type ModelParameters struct {

	// (Updatable) The OCID  for the models compartment.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/identity/v1alpha1.Compartment
	// +kubebuilder:validation:Optional
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// Reference to a Compartment in identity to populate compartmentId.
	// +kubebuilder:validation:Optional
	CompartmentIDRef *v1.Reference `json:"compartmentIdRef,omitempty" tf:"-"`

	// Selector for a Compartment in identity to populate compartmentId.
	// +kubebuilder:validation:Optional
	CompartmentIDSelector *v1.Selector `json:"compartmentIdSelector,omitempty" tf:"-"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) A short description of the a model.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) A user-friendly display name for the resource. It does not have to be unique and can be modified. Avoid entering confidential information.
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// Possible model types
	// +kubebuilder:validation:Optional
	ModelDetails []ModelDetailsParameters `json:"modelDetails,omitempty" tf:"model_details,omitempty"`

	// The OCID of the project to associate with the model.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/ailanguage/v1alpha1.Project
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// Reference to a Project in ailanguage to populate projectId.
	// +kubebuilder:validation:Optional
	ProjectIDRef *v1.Reference `json:"projectIdRef,omitempty" tf:"-"`

	// Selector for a Project in ailanguage to populate projectId.
	// +kubebuilder:validation:Optional
	ProjectIDSelector *v1.Selector `json:"projectIdSelector,omitempty" tf:"-"`

	// Possible strategy as testing and validation dataset.
	// +kubebuilder:validation:Optional
	TestStrategy []TestStrategyParameters `json:"testStrategy,omitempty" tf:"test_strategy,omitempty"`

	// Possible data set type
	// +kubebuilder:validation:Optional
	TrainingDataset []TrainingDatasetParameters `json:"trainingDataset,omitempty" tf:"training_dataset,omitempty"`
}

type TestStrategyInitParameters struct {

	// This information will define the test strategy different datasets for test and validation dataset.
	StrategyType *string `json:"strategyType,omitempty" tf:"strategy_type,omitempty"`

	// Possible data set type
	TestingDataset []TestingDatasetInitParameters `json:"testingDataset,omitempty" tf:"testing_dataset,omitempty"`

	// Possible data set type
	ValidationDataset []ValidationDatasetInitParameters `json:"validationDataset,omitempty" tf:"validation_dataset,omitempty"`
}

type TestStrategyObservation struct {

	// This information will define the test strategy different datasets for test and validation dataset.
	StrategyType *string `json:"strategyType,omitempty" tf:"strategy_type,omitempty"`

	// Possible data set type
	TestingDataset []TestingDatasetObservation `json:"testingDataset,omitempty" tf:"testing_dataset,omitempty"`

	// Possible data set type
	ValidationDataset []ValidationDatasetObservation `json:"validationDataset,omitempty" tf:"validation_dataset,omitempty"`
}

type TestStrategyParameters struct {

	// This information will define the test strategy different datasets for test and validation dataset.
	// +kubebuilder:validation:Optional
	StrategyType *string `json:"strategyType" tf:"strategy_type,omitempty"`

	// Possible data set type
	// +kubebuilder:validation:Optional
	TestingDataset []TestingDatasetParameters `json:"testingDataset" tf:"testing_dataset,omitempty"`

	// Possible data set type
	// +kubebuilder:validation:Optional
	ValidationDataset []ValidationDatasetParameters `json:"validationDataset,omitempty" tf:"validation_dataset,omitempty"`
}

type TestingDatasetInitParameters struct {

	// Data Science Labelling Service OCID
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/datalabelingservice/v1alpha1.Dataset
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	DatasetID *string `json:"datasetId,omitempty" tf:"dataset_id,omitempty"`

	// Reference to a Dataset in datalabelingservice to populate datasetId.
	// +kubebuilder:validation:Optional
	DatasetIDRef *v1.Reference `json:"datasetIdRef,omitempty" tf:"-"`

	// Selector for a Dataset in datalabelingservice to populate datasetId.
	// +kubebuilder:validation:Optional
	DatasetIDSelector *v1.Selector `json:"datasetIdSelector,omitempty" tf:"-"`

	// Possible data sets
	DatasetType *string `json:"datasetType,omitempty" tf:"dataset_type,omitempty"`

	// Possible object storage location types
	LocationDetails []LocationDetailsInitParameters `json:"locationDetails,omitempty" tf:"location_details,omitempty"`
}

type TestingDatasetObservation struct {

	// Data Science Labelling Service OCID
	DatasetID *string `json:"datasetId,omitempty" tf:"dataset_id,omitempty"`

	// Possible data sets
	DatasetType *string `json:"datasetType,omitempty" tf:"dataset_type,omitempty"`

	// Possible object storage location types
	LocationDetails []LocationDetailsObservation `json:"locationDetails,omitempty" tf:"location_details,omitempty"`
}

type TestingDatasetParameters struct {

	// Data Science Labelling Service OCID
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/datalabelingservice/v1alpha1.Dataset
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	DatasetID *string `json:"datasetId,omitempty" tf:"dataset_id,omitempty"`

	// Reference to a Dataset in datalabelingservice to populate datasetId.
	// +kubebuilder:validation:Optional
	DatasetIDRef *v1.Reference `json:"datasetIdRef,omitempty" tf:"-"`

	// Selector for a Dataset in datalabelingservice to populate datasetId.
	// +kubebuilder:validation:Optional
	DatasetIDSelector *v1.Selector `json:"datasetIdSelector,omitempty" tf:"-"`

	// Possible data sets
	// +kubebuilder:validation:Optional
	DatasetType *string `json:"datasetType" tf:"dataset_type,omitempty"`

	// Possible object storage location types
	// +kubebuilder:validation:Optional
	LocationDetails []LocationDetailsParameters `json:"locationDetails,omitempty" tf:"location_details,omitempty"`
}

type TrainingDatasetInitParameters struct {

	// Data Science Labelling Service OCID
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/datalabelingservice/v1alpha1.Dataset
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	DatasetID *string `json:"datasetId,omitempty" tf:"dataset_id,omitempty"`

	// Reference to a Dataset in datalabelingservice to populate datasetId.
	// +kubebuilder:validation:Optional
	DatasetIDRef *v1.Reference `json:"datasetIdRef,omitempty" tf:"-"`

	// Selector for a Dataset in datalabelingservice to populate datasetId.
	// +kubebuilder:validation:Optional
	DatasetIDSelector *v1.Selector `json:"datasetIdSelector,omitempty" tf:"-"`

	// Possible data sets
	DatasetType *string `json:"datasetType,omitempty" tf:"dataset_type,omitempty"`

	// Possible object storage location types
	LocationDetails []TrainingDatasetLocationDetailsInitParameters `json:"locationDetails,omitempty" tf:"location_details,omitempty"`
}

type TrainingDatasetLocationDetailsInitParameters struct {

	// Object storage bucket name
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// Possible object storage location types
	LocationType *string `json:"locationType,omitempty" tf:"location_type,omitempty"`

	// Object storage namespace
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Array of files which need to be processed in the bucket
	ObjectNames []*string `json:"objectNames,omitempty" tf:"object_names,omitempty"`
}

type TrainingDatasetLocationDetailsObservation struct {

	// Object storage bucket name
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// Possible object storage location types
	LocationType *string `json:"locationType,omitempty" tf:"location_type,omitempty"`

	// Object storage namespace
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Array of files which need to be processed in the bucket
	ObjectNames []*string `json:"objectNames,omitempty" tf:"object_names,omitempty"`
}

type TrainingDatasetLocationDetailsParameters struct {

	// Object storage bucket name
	// +kubebuilder:validation:Optional
	Bucket *string `json:"bucket" tf:"bucket,omitempty"`

	// Possible object storage location types
	// +kubebuilder:validation:Optional
	LocationType *string `json:"locationType" tf:"location_type,omitempty"`

	// Object storage namespace
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace" tf:"namespace,omitempty"`

	// Array of files which need to be processed in the bucket
	// +kubebuilder:validation:Optional
	ObjectNames []*string `json:"objectNames" tf:"object_names,omitempty"`
}

type TrainingDatasetObservation struct {

	// Data Science Labelling Service OCID
	DatasetID *string `json:"datasetId,omitempty" tf:"dataset_id,omitempty"`

	// Possible data sets
	DatasetType *string `json:"datasetType,omitempty" tf:"dataset_type,omitempty"`

	// Possible object storage location types
	LocationDetails []TrainingDatasetLocationDetailsObservation `json:"locationDetails,omitempty" tf:"location_details,omitempty"`
}

type TrainingDatasetParameters struct {

	// Data Science Labelling Service OCID
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/datalabelingservice/v1alpha1.Dataset
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	DatasetID *string `json:"datasetId,omitempty" tf:"dataset_id,omitempty"`

	// Reference to a Dataset in datalabelingservice to populate datasetId.
	// +kubebuilder:validation:Optional
	DatasetIDRef *v1.Reference `json:"datasetIdRef,omitempty" tf:"-"`

	// Selector for a Dataset in datalabelingservice to populate datasetId.
	// +kubebuilder:validation:Optional
	DatasetIDSelector *v1.Selector `json:"datasetIdSelector,omitempty" tf:"-"`

	// Possible data sets
	// +kubebuilder:validation:Optional
	DatasetType *string `json:"datasetType" tf:"dataset_type,omitempty"`

	// Possible object storage location types
	// +kubebuilder:validation:Optional
	LocationDetails []TrainingDatasetLocationDetailsParameters `json:"locationDetails,omitempty" tf:"location_details,omitempty"`
}

type ValidationDatasetInitParameters struct {

	// Data Science Labelling Service OCID
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/datalabelingservice/v1alpha1.Dataset
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	DatasetID *string `json:"datasetId,omitempty" tf:"dataset_id,omitempty"`

	// Reference to a Dataset in datalabelingservice to populate datasetId.
	// +kubebuilder:validation:Optional
	DatasetIDRef *v1.Reference `json:"datasetIdRef,omitempty" tf:"-"`

	// Selector for a Dataset in datalabelingservice to populate datasetId.
	// +kubebuilder:validation:Optional
	DatasetIDSelector *v1.Selector `json:"datasetIdSelector,omitempty" tf:"-"`

	// Possible data sets
	DatasetType *string `json:"datasetType,omitempty" tf:"dataset_type,omitempty"`

	// Possible object storage location types
	LocationDetails []ValidationDatasetLocationDetailsInitParameters `json:"locationDetails,omitempty" tf:"location_details,omitempty"`
}

type ValidationDatasetLocationDetailsInitParameters struct {

	// Object storage bucket name
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// Possible object storage location types
	LocationType *string `json:"locationType,omitempty" tf:"location_type,omitempty"`

	// Object storage namespace
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Array of files which need to be processed in the bucket
	ObjectNames []*string `json:"objectNames,omitempty" tf:"object_names,omitempty"`
}

type ValidationDatasetLocationDetailsObservation struct {

	// Object storage bucket name
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// Possible object storage location types
	LocationType *string `json:"locationType,omitempty" tf:"location_type,omitempty"`

	// Object storage namespace
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Array of files which need to be processed in the bucket
	ObjectNames []*string `json:"objectNames,omitempty" tf:"object_names,omitempty"`
}

type ValidationDatasetLocationDetailsParameters struct {

	// Object storage bucket name
	// +kubebuilder:validation:Optional
	Bucket *string `json:"bucket" tf:"bucket,omitempty"`

	// Possible object storage location types
	// +kubebuilder:validation:Optional
	LocationType *string `json:"locationType" tf:"location_type,omitempty"`

	// Object storage namespace
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace" tf:"namespace,omitempty"`

	// Array of files which need to be processed in the bucket
	// +kubebuilder:validation:Optional
	ObjectNames []*string `json:"objectNames" tf:"object_names,omitempty"`
}

type ValidationDatasetObservation struct {

	// Data Science Labelling Service OCID
	DatasetID *string `json:"datasetId,omitempty" tf:"dataset_id,omitempty"`

	// Possible data sets
	DatasetType *string `json:"datasetType,omitempty" tf:"dataset_type,omitempty"`

	// Possible object storage location types
	LocationDetails []ValidationDatasetLocationDetailsObservation `json:"locationDetails,omitempty" tf:"location_details,omitempty"`
}

type ValidationDatasetParameters struct {

	// Data Science Labelling Service OCID
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/datalabelingservice/v1alpha1.Dataset
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	DatasetID *string `json:"datasetId,omitempty" tf:"dataset_id,omitempty"`

	// Reference to a Dataset in datalabelingservice to populate datasetId.
	// +kubebuilder:validation:Optional
	DatasetIDRef *v1.Reference `json:"datasetIdRef,omitempty" tf:"-"`

	// Selector for a Dataset in datalabelingservice to populate datasetId.
	// +kubebuilder:validation:Optional
	DatasetIDSelector *v1.Selector `json:"datasetIdSelector,omitempty" tf:"-"`

	// Possible data sets
	// +kubebuilder:validation:Optional
	DatasetType *string `json:"datasetType" tf:"dataset_type,omitempty"`

	// Possible object storage location types
	// +kubebuilder:validation:Optional
	LocationDetails []ValidationDatasetLocationDetailsParameters `json:"locationDetails,omitempty" tf:"location_details,omitempty"`
}

// ModelSpec defines the desired state of Model
type ModelSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ModelParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ModelInitParameters `json:"initProvider,omitempty"`
}

// ModelStatus defines the observed state of Model.
type ModelStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ModelObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Model is the Schema for the Models API. Provides the Model resource in Oracle Cloud Infrastructure Ai Language service
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,oci}
type Model struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.modelDetails) || (has(self.initProvider) && has(self.initProvider.modelDetails))",message="spec.forProvider.modelDetails is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.trainingDataset) || (has(self.initProvider) && has(self.initProvider.trainingDataset))",message="spec.forProvider.trainingDataset is a required parameter"
	Spec   ModelSpec   `json:"spec"`
	Status ModelStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ModelList contains a list of Models
type ModelList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Model `json:"items"`
}

// Repository type metadata.
var (
	Model_Kind             = "Model"
	Model_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Model_Kind}.String()
	Model_KindAPIVersion   = Model_Kind + "." + CRDGroupVersion.String()
	Model_GroupVersionKind = CRDGroupVersion.WithKind(Model_Kind)
)

func init() {
	SchemeBuilder.Register(&Model{}, &ModelList{})
}
